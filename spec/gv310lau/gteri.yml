# Especificación estructurada del mensaje +RESP:GTERI para GV310LAU
# Objetivo: insumo legible por máquina para parsers, validadores y generación de tests.

name: "+RESP:GTERI"
device: "GV310LAU"
message_family: "ERI (Expand Fixed Report Information)"
encoding: "ASCII"
delimiter: ","
terminator: "$"
version_field:
  name: full_protocol_version
  length: 6
  format: hex
  example: "6E1203"

schema:
  sections:
    - name: head
      fields:
        - { name: header, const: "+RESP:GT", type: string }
        - { name: message, const: "ERI", type: string }
        - { name: full_protocol_version, type: hex, length: 6, example: "6E1203" }
        - { name: imei, type: string, length: 15, pattern: "^[0-9]{15}$", example: "864696060004173" }
        - { name: device_name, type: string, max_length: 20, pattern: "^[0-9A-Za-z_-]{1,20}$", example: "GV310LAU" }

    - name: body
      fields:
        - { name: eri_mask, type: hex, length: 8, example: "00000100" }
        - { name: external_power_mv, type: int, min: 0, max: 32000, nullable: true }
        - { name: report_type, type: string, length: 2, note: "X(1-5)Y(0-6)" }
        - { name: number, type: int, min: 1, max: 15 }
        - { name: gnss_accuracy_level, type: int, min: 0, max: 50 }
        - { name: speed_kmh, type: float, min: 0.0, max: 999.9 }
        - { name: azimuth_deg, type: int, min: 0, max: 359 }
        - { name: altitude_m, type: float, note: "(-)xxxxx.x" }
        - { name: longitude_deg, type: float, note: "(-)xxx.xxxxxx" }
        - { name: latitude_deg, type: float, note: "(-)xx.xxxxxx" }
        - { name: gnss_utc_time, type: datetime, format: "YYYYMMDDHHMMSS" }
        - { name: mcc, type: string, length: 4, pattern: "^0[0-9]{3}$" }
        - { name: mnc, type: string, length: 4, pattern: "^0[0-9]{3}$" }
        - { name: lac, type: hex, length: 4 }
        - { name: cell_id, type: hex, length_variant: [4,8] }
        - { name: position_append_mask, type: hex, length: 2, example: "03" }

        # Positional append fields (presence controlled by position_append_mask)
        - { name: sats_in_use, type: int, min: 0, max: 72, when: { mask: position_append_mask, bit: 0 } }
        - { name: hdop, type: float, min: 0.00, max: 99.99, when: { mask: position_append_mask, bit: 1 }, semantics: "0 => GNSS fix fail; >0 => HDOP actual" }
        - { name: vdop, type: float, min: 0.00, max: 99.99, when: { mask: position_append_mask, bit: 2 }, semantics: "0 => GNSS fix fail; >0 => VDOP actual" }
        - { name: pdop, type: float, min: 0.00, max: 99.99, when: { mask: position_append_mask, bit: 3 }, semantics: "0 => GNSS fix fail; >0 => PDOP actual" }

        - { name: mileage_km, type: float, min: 0.0, max: 4294967.0 }
        - { name: hour_meter, type: string, length: 13, pattern: "^[0-9]{7}:[0-9]{2}:[0-9]{2}$" }
        - { name: analog_in_1, type: analog_value }
        - { name: analog_in_2, type: analog_value }
        - { name: analog_in_3, type: analog_value }
        - { name: backup_battery_pct, type: int, min: 0, max: 100 }
        - { name: device_status, type: hex, length_variant: [6,10] }
        - { name: uart_device_type, type: enum, values: [0,1,2,5,6,7] }

        # Optional ERI blocks (presence controlled by eri_mask)
        - name: digital_fuel_sensor_data
          type: bytes
          max_length: 20
          when: { mask: eri_mask, bit: 0 }

        - name: one_wire_block
          type: object
          when: { mask: eri_mask, bit: 1 }
          properties:
            device_number: { type: int, min: 0, max: 19 }
            devices:
              type: array
              items:
                type: object
                properties:
                  id: { type: hex, length: 16 }
                  type: { type: int, enum: [1], note: "1 => temperature sensor" }
                  data_raw: { type: hex, max_length: 40, note: "two's complement; real_temp_c = decimal * 0.0625" }

        - name: can_data
          type: hex
          max_length: 1000
          when: { mask: eri_mask, bit: 2 }

        - name: fuel_sensor_block
          type: object
          when: { mask: eri_mask, bit: 10 }
          properties:
            sensor_number: { type: int, min: 0, max: 100 }
            sensors:
              type: array
              items:
                type: object
                properties:
                  type: { type: int, enum: [0,1,2,3,4,6,8,20,21,22] }
                  percentage: { type: float, min: 0.0, max: 100.0, nullable: true }
                  volume_l: { type: float, min: 0.0, max: 6000.0, nullable: true }
                  fuel_temperature_c: { type: int, min: -40, max: 85, nullable: true, when: { anyOf: [ { field: type, equals: 2 }, { field: type, equals: 6 } ] } }

        - name: rf433_block
          type: object
          optional: true
          properties:
            accessory_number: { type: int, min: 0, max: 10 }
            accessories:
              type: array
              items:
                type: object
                properties:
                  serial: { type: hex, length: 5 }
                  type: { type: int, enum: [1,2], note: "1=WTS100, 2=WTH100" }
                  temperature_c: { type: int, min: -20, max: 60 }
                  humidity_pct: { type: int, min: 0, max: 100, nullable: true, when: { field: type, equals: 2 } }

        - name: ble_block
          type: object
          optional: true
          properties:
            accessory_number: { type: int, min: 0, max: 25 }
            items:
              type: array
              items:
                type: object
                properties:
                  index: { type: string, pattern: "^(0[0-9]|0xFE)$" }
                  accessory_type: { type: int, enum: [0,1,2,3,6,7,8,10,11,12,13] }
                  model_or_beacon_id_model: { type: int, min: 0, max: 5 }
                  raw_data: { type: hex, max_length: 18, nullable: true }
                  append_mask: { type: hex, max_length: 4, nullable: true }
                  name: { type: string, max_length: 20, nullable: true }
                  mac: { type: hex, length: 12, nullable: true }
                  status: { type: int, enum: [0,1], nullable: true }
                  battery_mv: { type: int, min: 0, max: 5000, nullable: true }
                  temp_c: { type: float, min: -40.0, max: 80.0, nullable: true }
                  humidity_pct: { type: int, min: 0, max: 100, nullable: true }
                  output_status: { type: hex, length: 2, nullable: true }
                  digital_input_status: { type: hex, length: 2, nullable: true }
                  analog_input_mv: { type: int, min: 0, max: 32000, nullable: true }
                  mode: { type: int, min: 0, max: 10, nullable: true }
                  event: { type: int, enum: [0,1,2], nullable: true }
                  tire_pressure_kpa: { type: int, min: 0, max: 500, nullable: true }
                  timestamp: { type: datetime, format: "YYYYMMDDHHMMSS", nullable: true }
                  enhanced_temp_c: { type: float, min: -40.00, max: 80.00, nullable: true }
                  magnet_id: { type: hex, length: 2, nullable: true }
                  mag_event_counter: { type: int, min: 0, max: 32767, nullable: true }
                  magnet_state: { type: int, enum: [0,1], nullable: true }
                  battery_pct: { type: int, min: 0, max: 100, nullable: true }
                  relay_state: { type: int, enum: [0,1], nullable: true }

        - name: rat
          type: int
          optional: true
          when: { mask: eri_mask, bit: 13 }

        - name: band
          type: string
          optional: true
          when: { field_present: rat }

    - name: tail
      fields:
        - { name: send_time, type: datetime, format: "YYYYMMDDHHMMSS" }
        - { name: count_hex, type: hex, length: 4 }

# Tipos auxiliares
aux_types:
  analog_value:
    oneOf:
      - { type: int, min: 0, max: 16000, unit: mV }
      - { type: string, pattern: "^F(\d{1,3})$", note: "F0..F100 => porcentaje" }

masks:
  position_append_mask:
    bits:
      0: { field: sats_in_use }
      1: { field: hdop }
      2: { field: vdop }
      3: { field: pdop }
  eri_mask:
    bits:
      0: { block: digital_fuel_sensor_data }
      1: { block: one_wire_block }
      2: { block: can_data }
      10: { block: fuel_sensor_block }

ble_append_mask:
  bits:
    0:  { name: accessory_name }
    1:  { name: accessory_mac }
    2:  { name: accessory_status }
    3:  { name: accessory_battery_voltage }
    4:  { name: accessory_temperature }
    5:  { name: accessory_humidity }
    6:  { name: reserved }
    7:  { name: accessory_io }
    8:  { name: accessory_event }
    9:  { name: tire_pressure }
    10: { name: timestamp }
    11: { name: enhanced_temperature }
    12: { name: magnet_data }
    13: { name: accessory_battery_percentage }
    14: { name: relay_data }
    15: { name: valid_bits_0_14_when_0 }

validation:
  rules:
    - name: header_and_message
      assert: "header == '+RESP:GT' and message == 'ERI'"
    - name: terminator
      assert: "line.endswith('$')"
    - name: gnss_fix_semantics
      note: "Si hdop/vdop/pdop == 0 => gnss_fix=false y se usa última posición conocida."

examples:
  - raw: "+RESP:GTERI,6E1203,864696060004173,GV310LAU,00000100,,10,1,1,0.0,0,115.8,117.129356,31.839248,20230808061540,0460,0001,DF5C,05FE6667,03,15,,4.0,0000102:34:33,14549,42,11172,100,210000,0,1,0,06,12,0,001A42A2,0617,TMPS,08351B00043C,1,26,65,20231030085704,20231030085704,0017$"
    parsed_keys_must_include:
      - header
      - imei
      - eri_mask
      - longitude_deg
      - latitude_deg
      - position_append_mask
      - sats_in_use
      - hdop
      - mileage_km
      - hour_meter
      - send_time
      - count_hex

notes:
  - "Mantener valores crudos además de normalizados cuando haya conversiones (ej. data 1-wire, BLE raw)."
  - "Iterar bloques RF433/BLE según 'accessory_number' y aplicar ble_append_mask por ítem."
  - "Hour meter tiene formato fijo 0000000:00:00; validar longitud exacta."
